# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RemoteSensingARDTimeSeriesDownloaderDockWidget
                                 A QGIS plugin
 Remote sensing ARD time series downloader using OPENEO
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by David Hernández López
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, sys
import webbrowser
import subprocess
from osgeo import gdal, osr, ogr

from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QSettings, QTranslator, qVersion, \
    QCoreApplication, QFileInfo, QDir, QObject, QDate, QEvent
from qgis.PyQt.QtWidgets import QMessageBox, QInputDialog, QLineEdit, QFileDialog
from qgis.core import QgsApplication, QgsDataSourceUri,QgsMapLayerProxyModel, QgsRectangle, QgsGeometry, \
    QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject, QgsVectorLayer, QgsMapLayer
from qgis.core import *

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'rs_ard_time_series_downloader_dockwidget_base.ui'))

from .about_qdialog import AboutQDialog
from . import definitions


def authentication_callback(auth_message: str):
    if auth_message.__len__() and auth_message.split()[0] == 'Visit':
        webbrowser.open(auth_message.split()[1])


class RemoteSensingARDTimeSeriesDownloaderDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self,
                 iface,
                 pluginPath,
                 currentPluginName,
                 settings,
                 user_roaming_path,
                 openeo_auth_file_path,
                 parent=None):
        """Constructor."""
        super(RemoteSensingARDTimeSeriesDownloaderDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.windowTitle = definitions.CONST_PROGRAM_NAME
        self.iface = iface
        self.path_plugin = pluginPath
        self.current_plugin_name = currentPluginName
        self.settings = settings
        self.user_roaming_path = user_roaming_path
        self.openeo_auth_file_path = openeo_auth_file_path
        self.openeo_imported = False
        self.connection = None
        self.logged = False
        self.setupUi(self)
        self.initialize()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def display_msg_error(self, text):
        msgBox = QMessageBox()
        msgBox.setIcon(QMessageBox.Information)
        title = definitions.CONST_PROGRAM_TITLE
        msgBox.setWindowTitle(title)
        # msgBox.setTextFormat(Qt.RichText)
        msgBox.setText(text)
        msgBox.exec_()

    def initialize(self):
        self.about_qdialog = None
        # self.ee_uninitialized = True
        path_file_qsettings = self.path_plugin + '/' + definitions.CONST_SETTINGS_FILE_NAME
        self.settings = QSettings(path_file_qsettings,QSettings.IniFormat)
        qs = QSettings()
        self.about_qdialog = None
        self.aboutPushButton.clicked.connect(self.show_about_dialog)
        self.roiSelectedFeaturesRadioButton.toggled.connect(self.roi_from_selected_features)
        self.roiMapCanvasRadioButton.setChecked(True)
        self.outputPathPushButton.clicked.connect(self.select_output_path)
        # self.outputFileNamePushButton.clicked.connect(self.selectOutputFileName)
        self.processPushButton.clicked.connect(self.process)
        self.loadResultsPushButton.clicked.connect(self.load_results)
        self.loginPushButton.clicked.connect(self.login)
        self.logoutPushButton.clicked.connect(self.logout)

        pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
        thisFilePath = os.path.dirname(os.path.realpath(__file__))
        thisFilePath = os.path.join(pluginsPath, thisFilePath)

        self.templatePath = thisFilePath + definitions.CONST_TEMPLATE_PATH
        # self.qmlDNBRFileName = self.templatePath + definitions.CONST_DNBR_SYMBOLOGY_TEMPLATE

        self.path = self.settings.value(definitions.CONST_SETTINGS_LAST_PATH_TAG)
        if not self.path:
            self.path = QDir.currentPath()
            self.settings.setValue(definitions.CONST_SETTINGS_LAST_PATH_TAG,self.path)
            self.settings.sync()

        self.openEOProviderComboBox.addItem(definitions.CONST_NO_COMBO_SELECT)
        for provider in definitions.openEO_providers:
            self.openEOProviderComboBox.addItem(provider)
        if len(definitions.openEO_providers) == 1:
            self.openEOProviderComboBox.setCurrentIndex(1)
            self.openEOProviderComboBox.setEnabled(False)
        self.loginPushButton.setEnabled(True)
        self.logoutPushButton.setEnabled(False)
        # self.roiLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)
        # self.roiLayerComboBox.clear()
        # existing_vector_layers = [l for l in QgsProject().instance().mapLayers().values() if isinstance(l, QgsVectorLayer)]
        # self.roiLayerComboBox.setAdditionalLayers(existing_vector_layers)

        initialDateString = self.settings.value(definitions.CONST_SETTINGS_INITIAL_DATE_TAG)
        if not initialDateString:
            initialDateString = definitions.CONST_INITIAL_DATE_DEFAULT
        else:
            initialDate = QDate.fromString(initialDateString,
                                                  definitions.CONST_DATE_STRING_TEMPLATE)
            if not initialDate.isValid():
                initialDateString = definitions.CONST_INITIAL_DATE_DEFAULT
        self.settings.setValue(definitions.CONST_SETTINGS_INITIAL_DATE_TAG,
                               initialDateString)
        self.settings.sync()
        self.initialDateEdit.setDate(QDate.fromString(initialDateString,
                                                      definitions.CONST_DATE_STRING_TEMPLATE))

        finalDateString = self.settings.value(definitions.CONST_SETTINGS_FINAL_DATE_TAG)
        if not finalDateString:
            finalDateString = definitions.CONST_FINAL_DATE_DEFAULT
        else:
            finalDate = QDate.fromString(finalDateString,
                                                  definitions.CONST_DATE_STRING_TEMPLATE)
            if not finalDate.isValid():
                finalDateString = definitions.CONST_FINAL_DATE_DEFAULT
        self.settings.setValue(definitions.CONST_SETTINGS_FINAL_DATE_TAG,
                               finalDateString)
        self.settings.sync()
        self.finalDateEdit.setDate(QDate.fromString(finalDateString,
                                                          definitions.CONST_DATE_STRING_TEMPLATE))

        outputPath = self.settings.value(definitions.CONST_SETTINGS_OUTPUT_PATH_TAG)
        if outputPath:
            if os.path.exists(outputPath):
                self.outputPathLineEdit.setText(outputPath)
            else:
                self.settings.setValue(definitions.CONST_SETTINGS_OUTPUT_PATH_TAG,'')
                self.settings.sync()

        # outputFileName = self.settings.value(definitions.CONST_SETTINGS_OUTPUT_FILE_NAME_TAG)
        # if outputFileName:
            # self.outputFileNameLineEdit.setText(outputFileName)
        return

    def load_results(self):
        return

    def login(self):
        self.logged = False
        self.logoutPushButton.setEnabled(False)
        authenticated = False
        if self.connection:
            try:
                self.connection.authenticate_oidc_refresh_token()
                self.logged = True
                self.logoutPushButton.setEnabled(True)
                return
            except:
                self.logged = False
                authenticated = False
        self.logoutPushButton.setEnabled(False)
        openeo_provider = self.openEOProviderComboBox.currentText()
        if openeo_provider == definitions.CONST_NO_COMBO_SELECT:
            str_error = self.tr(u'Select OpenEO provider')
            self.display_msg_error(str_error)
            return
        backend_url = definitions.openEO_providers[openeo_provider]
        if not self.openeo_imported:
            try:
                import openeo
                self.openeo_imported = True
            except ImportError:
                str_error = self.tr(u'OPENEO is required')
                str_error += self.tr(u'Open QGIS python console and execute two commands:\n')
                str_error += (u'import pip\n')
                str_error += (u'pip.main(["install","openeo"])\n\n')
                str_error += self.tr(u'You must restart QGIS before use the plugin')
                self.display_msg_error(str_error)
                return
        self.connection = openeo.connect(backend_url)
        try:
            self.connection.authenticate_oidc(display=authentication_callback)#, max_poll_time=120)
        except openeo.rest.auth.oidc.OidcDeviceCodePollTimeout:
            str_error = self.tr(u'Authentication timeout (two minutes)')
            self.display_msg_error(str_error)
            self.connection = None
            return
        self.logged = True
        self.logoutPushButton.setEnabled(True)
        return

    def logout(self):
        result = subprocess.run(['python', self.openeo_auth_file_path, 'paths'], capture_output=True, text=True)
        text_resuts = result.stdout.split()
        refresh_tokens_file_path = ''
        for i in range(len(text_resuts)):
            if definitions.CONST_OPENEO_REFRESH_TOKENS in text_resuts[i]:
                if os.path.exists(text_resuts[i]):
                    refresh_tokens_file_path = text_resuts[i]
                    break
                else:
                    concatenated_text = text_resuts[i-1] + text_resuts[i]
                    if os.path.exists(concatenated_text):
                        refresh_tokens_file_path = concatenated_text
                        break
        if refresh_tokens_file_path:
            os.remove(refresh_tokens_file_path)
            self.logoutPushButton.setEnabled(False)
        return

    def process(self):
        self.login()
        if not self.logged:
            str_error = self.tr(u'Login before')
            self.display_msg_error(str_error)
            return
        initialJulianDate = self.initialDateEdit.date().toJulianDay()
        finalJulianDate = self.finalDateEdit.date().toJulianDay()
        if finalJulianDate <= initialJulianDate:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Final date must be later than initial date')
            self.display_msg_error(str_error)
            return
        if (finalJulianDate-initialJulianDate)<definitions.CONST_MINIMAL_DATES_INTERVAL:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'The date interval must be greater than {} days'
                                .format(str(definitions.CONST_MINIMAL_DATES_INTERVAL-1)))
            self.display_msg_error(str_error)
            return
        outputPath = self.outputPathLineEdit.text()
        if not outputPath:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Select output path')
            self.display_msg_error(str_error)
            return
        ogr_geometries_by_id = {}
        selection_crs = osr.SpatialReference()
        if self.roiMapCanvasRadioButton.isChecked():
            map_canvas_extent_wkt = self.iface.mapCanvas().extent().asWktPolygon()
            try:
                ogr_polygon = ogr.CreateGeometryFromWkt(map_canvas_extent_wkt)
            except Exception as e:
                str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
                self.display_msg_error(str_error)
                return
            ogr_geometries_by_id[definitions.CONST_OPENEO_MAPCANVAS_FEATURE_ID] = ogr_polygon
            map_canvas_crs_epsg_code_string = QgsProject.instance().crs().authid()
            try:
                # map_canvas_crs.ImportFromEPSG(map_canvas_crs_epsg_code)
                selection_crs.SetFromUserInput(map_canvas_crs_epsg_code_string)
            except Exception as e:
                str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
                self.display_msg_error(str_error)
                return
        else:
            if not self.iface.activeLayer():
                str_error = self.tr(u'Load, active and select features from a polygon vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            layer = self.iface.activeLayer()
            if not layer.type() == QgsMapLayer.VectorLayer:
                str_error = self.tr(u'Load, active and select features from a polygon vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            if not layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                str_error = self.tr(u'Load, active and select features from a polygon vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            numberOfFeaturesSelected = self.iface.activeLayer().selectedFeatureCount()
            if numberOfFeaturesSelected < 1:
                str_error = self.tr(u'Load, active and select features from a vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            selected_layer_crs_epsg_code_string = self.iface.activeLayer().crs().authid()
            try:
                # map_canvas_crs.ImportFromEPSG(map_canvas_crs_epsg_code)
                selection_crs.SetFromUserInput(selected_layer_crs_epsg_code_string)
            except Exception as e:
                str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
                self.display_msg_error(str_error)
                return
            field_id_name = ''
            for field in self.iface.activeLayer().fields():
                field_name = field.name
                for field_id_candidate in definitions.feature_field_id_candidates:
                    if field_name.lower() == field_id_candidate.lower():
                        field_id_name = field_name
                        break
            cont = 0
            for selectedFeature in self.iface.activeLayer().selectedFeatures():
                cont = cont + 1
                feature_id = ''
                if field_id_name:
                    feature_id = selectedFeature[field_id_name]
                else:
                    feature_id = str(cont)
                ogr_polygon = selectedFeature.geometry()
                ogr_geometries_by_id[feature_id] = ogr_polygon
        yo = 1
        # datacube = self.connection.load_collection(
        #     "SENTINEL2_L2A",
        #     spatial_extent={"west": -2.03972707113385754,
        #                     "south": 39.03063545672786461,
        #                     "east": -1.96169237963565957,
        #                     "north": 39.0524381142519843},
        #     temporal_extent=["2024-07-01", "2024-08-30"],
        #     # bands=["B02", "B04", "B08"],
        #     bands=["B04", "B08"],
        #     max_cloud_cover=85,
        # )
        # red = datacube.band("B04") * 0.0001
        # nir = datacube.band("B08") * 0.0001
        # ndvi_cube = (nir - red) / (nir + red)
        # # # Because GeoTIFF does not support a temporal dimension, we first eliminate it by taking the temporal maximum value for each pixel:
        # ndvi_composite = ndvi_cube.max_time()
        # download_file = outputPath + "/ndvi_kk.tif"
        # ndvi_composite.download(download_file)
        str_error = self.tr(u'Process finished')
        self.display_msg_error(str_error)

        return

    def roi_from_selected_features(self):
        if not self.roiSelectedFeaturesRadioButton.isChecked():
            return
        if not self.iface.activeLayer():
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Load, active and select features from a vector layer before')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return
        layer = self.iface.activeLayer()
        if not layer.type() == QgsMapLayer.VectorLayer:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Load, active and select features from a vector layer before')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return
        numberOfFeaturesSelected = self.iface.activeLayer().selectedFeatureCount()
        if numberOfFeaturesSelected < 1:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Load, active and select features from a vector layer before')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return

    def select_output_path(self):
        oldText = self.outputPathLineEdit.text()
        title = definitions.CONST_PROGRAM_TITLE
        label = "Select output path for store results:"
        path = QFileDialog.getExistingDirectory(self, label, self.path)
        if path:
            self.outputPathLineEdit.setText(path)
            self.settings.setValue(definitions.CONST_SETTINGS_OUTPUT_PATH_TAG, path)
            self.settings.setValue(definitions.CONST_SETTINGS_LAST_PATH_TAG, path)
            self.settings.sync()
        return

    def show_about_dialog(self):
        if self.about_qdialog == None:
            self.about_qdialog = AboutQDialog()
        self.about_qdialog.show()
