# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RemoteSensingARDTimeSeriesDownloaderDockWidget
                                 A QGIS plugin
 Remote sensing ARD time series downloader using OPENEO
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by David Hernández López
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, sys
import webbrowser
import subprocess
from osgeo import gdal, osr, ogr
import json
from os import listdir
from os.path import isfile, join

from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QSettings, QTranslator, qVersion, \
    QCoreApplication, QFileInfo, QDir, QObject, QDate, QEvent
from qgis.PyQt.QtWidgets import QMessageBox, QInputDialog, QLineEdit, \
    QFileDialog, QDockWidget, QTreeView, QHeaderView, QDialog, QVBoxLayout, QLabel
# from qgis.PyQt.QtGui import QPixmap
# from qgis.PyQt.QtCore import Qt.IgnoreAspectRatio
from qgis.PyQt.QtGui import QPixmap
from qgis.core import QgsApplication, QgsDataSourceUri,QgsMapLayerProxyModel, QgsRectangle, QgsGeometry, \
    QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject, QgsVectorLayer, QgsMapLayer
from qgis.core import *
import console

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'rs_ard_time_series_downloader_dockwidget_base.ui'))

from .about_qdialog import AboutQDialog
from . import definitions
from jsonmodel import JsonModel


def authentication_callback(auth_message: str):
    if auth_message.__len__() and auth_message.split()[0] == 'Visit':
        webbrowser.open(auth_message.split()[1])


class RemoteSensingARDTimeSeriesDownloaderDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self,
                 iface,
                 pluginPath,
                 currentPluginName,
                 settings,
                 user_roaming_path,
                 openeo_auth_file_path,
                 parent=None):
        """Constructor."""
        super(RemoteSensingARDTimeSeriesDownloaderDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.windowTitle = definitions.CONST_PROGRAM_NAME
        self.iface = iface
        self.path_plugin = pluginPath
        self.current_plugin_name = currentPluginName
        self.settings = settings
        self.user_roaming_path = user_roaming_path
        self.openeo_auth_file_path = openeo_auth_file_path
        self.openeo_imported = False
        self.connection = None
        self.logged = False
        self.bands_ids_candidates = None
        self.results_paths = None
        self.setupUi(self)
        self.initialize()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def collection_info(self):
        provider_id = self.openEOProviderComboBox.currentText()
        collection_id = self.collectionComboBox.currentText()
        if not provider_id in definitions.collection_info_image_file_by_provider_by_collection:
            return
        if not collection_id in definitions.collection_info_image_file_by_provider_by_collection[provider_id]:
            return
        image_file_path = self.path_plugin + definitions.collection_info_image_files_base_path + "\\"
        image_file_path += definitions.collection_info_image_file_by_provider_by_collection[provider_id][collection_id]
        dialog = QDialog()
        dialog.setWindowTitle("Collection info")
        pixmap = QPixmap(image_file_path)
        label = QLabel()
        label.setPixmap(pixmap)
        self.resize(int(pixmap.width() / 2), int(pixmap.height() / 2))
        dialog_layout = QVBoxLayout()
        dialog_layout.addWidget(label)
        dialog.setLayout(dialog_layout)
        dialog.exec_()
        return

    def display_msg_error(self, text):
        msgBox = QMessageBox()
        msgBox.setIcon(QMessageBox.Information)
        title = definitions.CONST_PROGRAM_TITLE
        msgBox.setWindowTitle(title)
        # msgBox.setTextFormat(Qt.RichText)
        msgBox.setText(text)
        msgBox.exec_()

    def initialize(self):
        self.about_qdialog = None
        path_file_qsettings = self.path_plugin + '/' + definitions.CONST_SETTINGS_FILE_NAME
        self.settings = QSettings(path_file_qsettings,QSettings.IniFormat)
        qs = QSettings()
        self.about_qdialog = None
        self.aboutPushButton.clicked.connect(self.show_about_dialog)
        self.collectionInfoPushButton.clicked.connect(self.collection_info)
        self.roiSelectedFeaturesRadioButton.toggled.connect(self.roi_from_selected_features)
        self.roiMapCanvasRadioButton.setChecked(True)
        self.outputPathPushButton.clicked.connect(self.select_output_path)
        self.processPushButton.clicked.connect(self.process)
        self.loadResultsPushButton.clicked.connect(self.load_results)
        self.loginPushButton.clicked.connect(self.login)
        self.logoutPushButton.clicked.connect(self.logout)
        pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
        thisFilePath = os.path.dirname(os.path.realpath(__file__))
        thisFilePath = os.path.join(pluginsPath, thisFilePath)
        self.templatePath = thisFilePath + definitions.CONST_TEMPLATE_PATH
        self.path = self.settings.value(definitions.CONST_SETTINGS_LAST_PATH_TAG)
        if not self.path:
            self.path = QDir.currentPath()
            self.settings.setValue(definitions.CONST_SETTINGS_LAST_PATH_TAG,self.path)
            self.settings.sync()
        self.openEOProviderComboBox.addItem(definitions.CONST_NO_COMBO_SELECT)
        for provider in definitions.openEO_providers:
            self.openEOProviderComboBox.addItem(provider)
        # self.openEOProviderComboBox.currentIndexChanged.connect(self.select_provider)
        if len(definitions.openEO_providers) == 1:
            self.openEOProviderComboBox.setCurrentIndex(1)
            self.openEOProviderComboBox.setEnabled(False)
        self.loginPushButton.setEnabled(True)
        self.collectionComboBox.currentIndexChanged.connect(self.select_connection)
        self.collectionMetadataPushButton.clicked.connect(self.show_collection_metadata)
        self.bandsPushButton.clicked.connect(self.select_bands)
        self.indexComboBox.currentIndexChanged.connect(self.select_index)
        initialDateString = self.settings.value(definitions.CONST_SETTINGS_INITIAL_DATE_TAG)
        if not initialDateString:
            initialDateString = definitions.CONST_INITIAL_DATE_DEFAULT
        else:
            initialDate = QDate.fromString(initialDateString,
                                                  definitions.CONST_DATE_STRING_TEMPLATE)
            if not initialDate.isValid():
                initialDateString = definitions.CONST_INITIAL_DATE_DEFAULT
        self.settings.setValue(definitions.CONST_SETTINGS_INITIAL_DATE_TAG,
                               initialDateString)
        self.settings.sync()
        self.initialDateEdit.setDate(QDate.fromString(initialDateString,
                                                      definitions.CONST_DATE_STRING_TEMPLATE))

        finalDateString = self.settings.value(definitions.CONST_SETTINGS_FINAL_DATE_TAG)
        if not finalDateString:
            finalDateString = definitions.CONST_FINAL_DATE_DEFAULT
        else:
            finalDate = QDate.fromString(finalDateString,
                                                  definitions.CONST_DATE_STRING_TEMPLATE)
            if not finalDate.isValid():
                finalDateString = definitions.CONST_FINAL_DATE_DEFAULT
        self.settings.setValue(definitions.CONST_SETTINGS_FINAL_DATE_TAG,
                               finalDateString)
        self.settings.sync()
        self.finalDateEdit.setDate(QDate.fromString(finalDateString,
                                                          definitions.CONST_DATE_STRING_TEMPLATE))

        outputPath = self.settings.value(definitions.CONST_SETTINGS_OUTPUT_PATH_TAG)
        if outputPath:
            if os.path.exists(outputPath):
                self.outputPathLineEdit.setText(outputPath)
            else:
                self.settings.setValue(definitions.CONST_SETTINGS_OUTPUT_PATH_TAG,'')
                self.settings.sync()
        self.update_gui()
        return

    def load_collections(self):
        openEO_provider= self.openEOProviderComboBox.currentText()
        if openEO_provider == definitions.CONST_NO_COMBO_SELECT:
            str_error = self.tr(u'Select openEO provider')
            self.display_msg_error(str_error)
            return
        if not self.connection:
            str_error = self.tr(u'Login before')
            self.display_msg_error(str_error)
            return
        collections = self.connection.list_collections()
        self.collectionComboBox.clear()
        if len(collections) == 0:
            str_error = self.tr(u'There are no collections in openEO Provider:\n{}'.format(openEO_provider))
            self.display_msg_error(str_error)
            return
        self.collectionComboBox.currentIndexChanged.disconnect(self.select_connection)
        self.collectionComboBox.addItem(definitions.CONST_NO_COMBO_SELECT)
        for i in range(len(collections)):
            collection_id = collections[i]['id']
            self.collectionComboBox.addItem(collection_id)
        self.collectionComboBox.currentIndexChanged.connect(self.select_connection)
        return

    def load_results(self):
        if not self.results_paths:
            return
        for i in range(len(self.results_paths)):
            result_path = self.results_paths[i]
            if not os.path.exists(result_path):
                continue
            files = [f for f in listdir(result_path) if isfile(join(result_path, f))]
            geotiff_files = {}
            for file in files:
                if file.endswith(".tif") or file.endswith(".TIF"):
                    file_base_name = os.path.splitext(os.path.basename(file))[0]
                    file_path = result_path + "\\" + file
                    file_path = os.path.normpath(file_path)
                    geotiff_files[file_base_name] = file_path
            if not bool(geotiff_files):
                continue
            group_name = os.path.basename(os.path.normpath(result_path))
            root = QgsProject.instance().layerTreeRoot()
            layer_group = None
            for group in root.findGroups():
                if group.name() == group_name:
                    group = root.removeChildNode(group_name)
                    break
            group = root.addGroup(group_name)
            for geotiff_file in geotiff_files:
                file_name = geotiff_files[geotiff_file]
                raster_layer = QgsRasterLayer(file_name, geotiff_file)
                QgsProject.instance().addMapLayer(raster_layer, False)
                group.insertChildNode(1, QgsLayerTreeLayer(raster_layer))
        return

    def login(self):
        self.logged = False
        self.update_gui()
        authenticated = False
        if self.connection:
            try:
                self.connection.authenticate_oidc_refresh_token()
                self.logged = True
                self.logoutPushButton.setEnabled(True)
                return
            except:
                self.logged = False
                authenticated = False
        self.logoutPushButton.setEnabled(False)
        openeo_provider = self.openEOProviderComboBox.currentText()
        if openeo_provider == definitions.CONST_NO_COMBO_SELECT:
            str_error = self.tr(u'Select OpenEO provider')
            self.display_msg_error(str_error)
            return
        backend_url = definitions.openEO_providers[openeo_provider]
        try:
            import openeo
            self.openeo_imported = True
        except ImportError:
            str_error = self.tr(u'OPENEO is required')
            str_error += self.tr(u'Open QGIS python console and execute two commands:\n')
            str_error += (u'import pip\n')
            str_error += (u'pip.main(["install","openeo"])\n\n')
            str_error += self.tr(u'You must restart QGIS before use the plugin')
            self.display_msg_error(str_error)
            return
        self.connection = openeo.connect(backend_url)
        try:
            self.connection.authenticate_oidc(display=authentication_callback)#, max_poll_time=120)
        except openeo.rest.auth.oidc.OidcDeviceCodePollTimeout:
            str_error = self.tr(u'Authentication timeout (two minutes)')
            self.display_msg_error(str_error)
            self.connection = None
            return
        self.load_collections()
        self.logged = True
        self.update_gui()
        return

    def logout(self):
        result = subprocess.run(['python', self.openeo_auth_file_path, 'paths'], capture_output=True, text=True)
        text_resuts = result.stdout.split()
        refresh_tokens_file_path = ''
        for i in range(len(text_resuts)):
            if definitions.CONST_OPENEO_REFRESH_TOKENS in text_resuts[i]:
                if os.path.exists(text_resuts[i]):
                    refresh_tokens_file_path = text_resuts[i]
                    break
                else:
                    concatenated_text = text_resuts[i-1] + text_resuts[i]
                    if os.path.exists(concatenated_text):
                        refresh_tokens_file_path = concatenated_text
                        break
        if refresh_tokens_file_path:
            os.remove(refresh_tokens_file_path)
        self.logged = False
        self.update_gui()
        return

    def process(self):
        self.results_paths = None
        provider_id = self.openEOProviderComboBox.currentText()
        collection_id = self.collectionComboBox.currentText()
        initialJulianDate = self.initialDateEdit.date().toJulianDay()
        finalJulianDate = self.finalDateEdit.date().toJulianDay()
        if finalJulianDate <= initialJulianDate:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Final date must be later than initial date')
            self.display_msg_error(str_error)
            return
        if (finalJulianDate-initialJulianDate)<definitions.CONST_MINIMAL_DATES_INTERVAL:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'The date interval must be greater than {} days'
                                .format(str(definitions.CONST_MINIMAL_DATES_INTERVAL-1)))
            self.display_msg_error(str_error)
            return
        str_first_date = self.initialDateEdit.date().toString('yyyy-MM-dd')
        str_last_date = self.finalDateEdit.date().toString('yyyy-MM-dd')
        temporal_extent = []  # ["2024-06-01", "2024-06-04"]
        temporal_extent.append(str_first_date)
        temporal_extent.append(str_last_date)
        outputPath = self.outputPathLineEdit.text()
        if not outputPath:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Select output path')
            self.display_msg_error(str_error)
            return
        ogr_geometries_by_id = {}
        source_crs = osr.SpatialReference()
        if self.roiMapCanvasRadioButton.isChecked():
            map_canvas_extent_wkt = self.iface.mapCanvas().extent().asWktPolygon()
            try:
                ogr_polygon = ogr.CreateGeometryFromWkt(map_canvas_extent_wkt)
            except Exception as e:
                str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
                self.display_msg_error(str_error)
                return
            ogr_geometries_by_id[definitions.CONST_OPENEO_MAPCANVAS_FEATURE_ID] = ogr_polygon
            map_canvas_crs_epsg_code_string = QgsProject.instance().crs().authid()
            try:
                # map_canvas_crs.ImportFromEPSG(map_canvas_crs_epsg_code)
                source_crs.SetFromUserInput(map_canvas_crs_epsg_code_string)
            except Exception as e:
                str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
                self.display_msg_error(str_error)
                return
        else:
            if not self.iface.activeLayer():
                str_error = self.tr(u'Load, active and select features from a polygon vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            layer = self.iface.activeLayer()
            if not layer.type() == QgsMapLayer.VectorLayer:
                str_error = self.tr(u'Load, active and select features from a polygon vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            if not layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                str_error = self.tr(u'Load, active and select features from a polygon vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            numberOfFeaturesSelected = self.iface.activeLayer().selectedFeatureCount()
            if numberOfFeaturesSelected < 1:
                str_error = self.tr(u'Load, active and select features from a vector layer before')
                self.display_msg_error(str_error)
                self.roiMapCanvasRadioButton.setChecked(True)
                return
            selected_layer_crs_epsg_code_string = self.iface.activeLayer().crs().authid()
            try:
                # map_canvas_crs.ImportFromEPSG(map_canvas_crs_epsg_code)
                source_crs.SetFromUserInput(selected_layer_crs_epsg_code_string)
            except Exception as e:
                str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
                self.display_msg_error(str_error)
                return
            field_id_name = ''
            for field_id_candidate in definitions.feature_field_id_candidates:
                for field in self.iface.activeLayer().fields():
                    field_name = field.name()
                    if field_name.lower() == field_id_candidate.lower():
                        field_id_name = field_name
                        break
                if field_id_name:
                    break
            cont = 0
            for selectedFeature in self.iface.activeLayer().selectedFeatures():
                cont = cont + 1
                feature_id = ''
                if field_id_name:
                    feature_id = str(selectedFeature[field_id_name])
                else:
                    feature_id = str(cont)
                feature_geometry = selectedFeature.geometry()
                geometry_wkt = feature_geometry.asWkt()
                try:
                    ogr_polygon = ogr.CreateGeometryFromWkt(geometry_wkt)
                except Exception as e:
                    str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
                    self.display_msg_error(str_error)
                    return
                ogr_geometries_by_id[feature_id] = ogr_polygon
        source_crs.SetAxisMappingStrategy(osr.OAMS_TRADITIONAL_GIS_ORDER)
        target_crs = osr.SpatialReference()
        try:
            # map_canvas_crs.ImportFromEPSG(map_canvas_crs_epsg_code)
            target_crs.SetFromUserInput(definitions.CONST_OPENEO_CRS_EPSG_STRING)
        except Exception as e:
            str_error = ('GDAL Error: ' + gdal.GetLastErrorMsg())
            self.display_msg_error(str_error)
            return
        target_crs.SetAxisMappingStrategy(osr.OAMS_TRADITIONAL_GIS_ORDER)
        crs_operation = osr.CoordinateTransformation(source_crs, target_crs)
        # pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        # if not pythonConsole or not pythonConsole.isVisible():
        #     self.iface.actionShowPythonDialog().trigger()
        #     pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        #     pythonConsole.setVisible(True)
        #     self.iface.mainWindow().update()
        bands = []
        str_bands = self.bandsLineEdit.text()
        if str_bands:
            bands = str_bands.split(';')
        index = self.indexComboBox.currentText()
        index_bands = None
        if provider_id in definitions.index_by_connection_by_provider:
            if collection_id in definitions.index_by_connection_by_provider[provider_id]:
                if index in definitions.index_by_connection_by_provider[provider_id][collection_id]:
                    index_bands = definitions.index_by_connection_by_provider[provider_id][collection_id][index]
                    for index_band in index_bands:
                        if not index_band in bands:
                            bands.append(index_band)
        # bands = definitions.openeo_sentinel2_bands
        self.results_paths = []
        cont = 0
        for feature_id in ogr_geometries_by_id:
            ogr_geometry = ogr_geometries_by_id[feature_id]
            ogr_geometry_as_wkt = ogr_geometry.ExportToWkt()
            ogr_geometry.Transform(crs_operation)
            ogr_geometry_crs_operation_as_wkt = ogr_geometry.ExportToWkt()
            env = ogr_geometry.GetEnvelope()
            feature_min_longitude = env[0]
            feature_min_latitude = env[2]
            feature_max_longitude = env[1]
            feature_max_latitude = env[3]
            feature_output_path = outputPath + '/' + feature_id
            feature_output_path_index = ''
            if index_bands:
                feature_output_path_index = feature_output_path + '_' + index
                feature_output_path_index = os.path.normpath(feature_output_path_index)
                if not os.path.exists(feature_output_path_index):
                    try:
                        os.mkdir(feature_output_path_index)
                    except FileExistsError:
                        str_error = f"\nDirectory '{feature_output_path_index}' already exists."
                        self.display_msg_error(str_error)
                        return
                    except PermissionError:
                        str_error = f"\nPermission denied: Unable to create '{feature_output_path_index}'."
                        self.display_msg_error(str_error)
                        return
                    except Exception as e:
                        str_error = f"\nAn error occurred: {e}"
                        self.display_msg_error(str_error)
                        return
                self.results_paths.append(feature_output_path_index)
            feature_output_path_bands = feature_output_path + definitions.CONST_OUTPUT_PATH_BANDS
            feature_output_path_bands = os.path.normpath(feature_output_path_bands)
            if not os.path.exists(feature_output_path_bands):
                try:
                    os.mkdir(feature_output_path_bands)
                except FileExistsError:
                    str_error = f"\nDirectory '{feature_output_path_bands}' already exists."
                    self.display_msg_error(str_error)
                    return
                except PermissionError:
                    str_error = f"\nPermission denied: Unable to create '{feature_output_path_bands}'."
                    self.display_msg_error(str_error)
                    return
                except Exception as e:
                    str_error = f"\nAn error occurred: {e}"
                    self.display_msg_error(str_error)
                    return
            self.results_paths.append(feature_output_path_bands)
            spatial_extent = {}
            spatial_extent["west"] = feature_min_longitude
            spatial_extent["south"] = feature_min_latitude
            spatial_extent["east"] = feature_max_longitude
            spatial_extent["north"] = feature_max_latitude
            datacube = self.connection.load_collection(definitions.openeo_sentinel2_l2a_tag,
                                                       spatial_extent,
                                                       temporal_extent,
                                                       bands,
                                                     )
            index_first_band_id = index_bands[0]
            index_second_band_id = index_bands[1]
            index_first_band = datacube.band(index_first_band_id)
            index_second_band = datacube.band(index_second_band_id)
            # red = datacube.band("B04")
            # nir = datacube.band("B08")
            # datacube = datacube.filter_bands(["B11", "B08", "B02"])
            # datacube_ndvi = (nir - red) / (nir + red)
            datacube_index = (index_second_band - index_first_band) / (index_second_band + index_first_band)
            datacube_ndvi_as_json_string = datacube_index.to_json()
            datacube_ndvi_as_dict = json.loads(datacube_ndvi_as_json_string)
            result_ndvi = datacube_index.save_result("GTiff")
            job_ndvi = result_ndvi.create_job()
            print("\nProcessing index for feature: {}".format(feature_id), flush=True)
            job_ndvi.start_and_wait()
            job_ndvi.get_results().download_files(feature_output_path_index)
            print("\n ... Process finished", flush=True)
            result_agronomy= datacube.save_result("GTiff")
            job_agronomy = result_agronomy.create_job()
            print("\nProcessing bands for feature: {}".format(feature_id), flush=True)
            job_agronomy.start_and_wait()
            job_agronomy.get_results().download_files(feature_output_path_bands)
            print("\n ... Process finished", flush=True)
            cont = cont + 1
            print("\n ... {} elements remain to be processed".format(str(len(ogr_geometries_by_id) - cont)), flush=True)

        # datacube = self.connection.load_collection(
        #     "SENTINEL2_L2A",
        #     spatial_extent={"west": -2.03972707113385754,
        #                     "south": 39.03063545672786461,
        #                     "east": -1.96169237963565957,
        #                     "north": 39.0524381142519843},
        #     temporal_extent=["2024-07-01", "2024-08-30"],
        #     # bands=["B02", "B04", "B08"],
        #     bands=["B04", "B08"],
        #     max_cloud_cover=85,
        # )
        # red = datacube.band("B04") * 0.0001
        # nir = datacube.band("B08") * 0.0001
        # ndvi_cube = (nir - red) / (nir + red)
        # # # Because GeoTIFF does not support a temporal dimension, we first eliminate it by taking the temporal maximum value for each pixel:
        # ndvi_composite = ndvi_cube.max_time()
        # download_file = outputPath + "/ndvi_kk.tif"
        # ndvi_composite.download(download_file)
        str_error = self.tr(u'Process finished')
        self.display_msg_error(str_error)
        return

    def roi_from_selected_features(self):
        if not self.roiSelectedFeaturesRadioButton.isChecked():
            return
        if not self.iface.activeLayer():
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Load, active and select features from a vector layer before')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return
        layer = self.iface.activeLayer()
        if not layer.type() == QgsMapLayer.VectorLayer:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Load, active and select features from a vector layer before')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return
        numberOfFeaturesSelected = self.iface.activeLayer().selectedFeatureCount()
        if numberOfFeaturesSelected < 1:
            # str_error = 'Clase: ' + type(self).__name__ + ', function: ' + sys._getframe().f_code.co_name
            # str_error += self.tr(u'\n\n Load, active and select features from a vector layer before')
            str_error = self.tr(u'Load, active and select features from a vector layer before')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return

    def select_bands(self):
        current_text = self.bandsLineEdit.text()
        text, ok = QInputDialog().getText(self, "Bands identifiers",
                                          "Bands (separated by ;):", QLineEdit.Normal,
                                          current_text)
        if ok and text:
            bands = text.split(';')
            for band in bands:
                if not band in self.bands_ids_candidates:
                    provider_id = self.openEOProviderComboBox.currentText()
                    collection_id = self.collectionComboBox.currentText()
                    str_error = self.tr(u'Band is not included in collection: {}'.format(collection_id))
                    str_error += self.tr(u'\nin provider: {}'.format(provider_id))
                    str_error += self.tr(u'\nBand candidates:')
                    for band_candidate in self.bands_ids_candidates:
                        str_error += self.tr(u'\nBand id: {}'.format(band_candidate))
                    self.display_msg_error(str_error)
                    return
            if len(bands) > 0:
                self.bandsLineEdit.setText(text)
        self.update_gui()

    def select_connection(self):
        self.bandsLineEdit.clear()
        self.indexComboBox.clear()
        self.bands_ids_candidates = None
        self.update_gui()
        openEO_provider = self.openEOProviderComboBox.currentText()
        if not openEO_provider in definitions.valid_connections_by_openEO_provider:
            str_error = self.tr(u'Invalid openEO provider')
            self.display_msg_error(str_error)
            return
        collection_id= self.collectionComboBox.currentText()
        if collection_id == definitions.CONST_NO_COMBO_SELECT:
            str_error = self.tr(u'Select connection')
            self.display_msg_error(str_error)
            return
        if not openEO_provider in definitions.valid_connections_by_openEO_provider:
            str_error = self.tr(u'Provider is not valid in this plugin version')
            self.display_msg_error(str_error)
            self.collectionComboBox.setCurrentIndex(0)
            return
        if not openEO_provider in definitions.bands_tags_connection_by_provider:
            str_error = self.tr(u'Provider is not valid in this plugin version')
            self.display_msg_error(str_error)
            self.collectionComboBox.setCurrentIndex(0)
            return
        if not collection_id in definitions.bands_tags_connection_by_provider[openEO_provider]:
            str_error = self.tr(u'There are no bands tags definition for provider: {}'.format(openEO_provider))
            str_error += self.tr(u'\nConnection is not valid in this plugin version')
            self.display_msg_error(str_error)
            self.collectionComboBox.setCurrentIndex(0)
            return
        collection_metadata = self.connection.describe_collection(collection_id)
        collection_metadata_iterate = collection_metadata
        collection_band_values = None
        for bands_tags in definitions.bands_tags_connection_by_provider[openEO_provider][collection_id]:
            if not bands_tags in collection_metadata_iterate:
                str_error = self.tr(u'No tag: {} in bands definition for provider: {} and collection: {}'.
                                    format(bands_tags, openEO_provider, collection_id))
                self.display_msg_error(str_error)
                self.collectionComboBox.setCurrentIndex(0)
                return
            collection_metadata_iterate = collection_metadata_iterate[bands_tags]
        if not collection_id in definitions.valid_connections_by_openEO_provider[openEO_provider]:
            str_error = self.tr(u'Connection is not valid in this plugin version')
            self.display_msg_error(str_error)
            self.collectionComboBox.setCurrentIndex(0)
            return
        if openEO_provider in definitions.index_by_connection_by_provider:
            if collection_id in definitions.index_by_connection_by_provider[openEO_provider]:
                self.indexComboBox.addItem(definitions.CONST_NO_COMBO_SELECT)
                for index_id in definitions.index_by_connection_by_provider[openEO_provider][collection_id]:
                    self.indexComboBox.addItem(index_id)
        self.bands_ids_candidates = collection_metadata_iterate
        self.update_gui()

    def select_index(self):
        self.update_gui()
        return

    def select_output_path(self):
        oldText = self.outputPathLineEdit.text()
        title = definitions.CONST_PROGRAM_TITLE
        label = "Select output path for store results:"
        path = QFileDialog.getExistingDirectory(self, label, self.path)
        if path:
            self.outputPathLineEdit.setText(path)
            self.settings.setValue(definitions.CONST_SETTINGS_OUTPUT_PATH_TAG, path)
            self.settings.setValue(definitions.CONST_SETTINGS_LAST_PATH_TAG, path)
            self.settings.sync()
        self.update_gui()
        return

    def show_about_dialog(self):
        if self.about_qdialog == None:
            self.about_qdialog = AboutQDialog()
        self.about_qdialog.show()

    def show_collection_metadata(self):
        openEO_provider= self.openEOProviderComboBox.currentText()
        if openEO_provider == definitions.CONST_NO_COMBO_SELECT:
            str_error = self.tr(u'Select openEO provider')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return
        if not self.connection:
            str_error = self.tr(u'Login before')
            self.display_msg_error(str_error)
            self.roiMapCanvasRadioButton.setChecked(True)
            return
        collection_id = self.collectionComboBox.currentText()
        collection_metadata = self.connection.describe_collection(collection_id)
        json_object = json.dumps(collection_metadata, indent=4)
        view = QTreeView()
        model = JsonModel()
        view.setModel(model)
        view.header().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        view.setAlternatingRowColors(True)
        view.resize(500, 300)
        model.load(collection_metadata)
        dialog = QDialog(self)
        dialog.setWindowTitle("Collection metadata")
        dialog_layout = QVBoxLayout()
        dialog_layout.addWidget(view)
        dialog.setLayout(dialog_layout)
        dialog.exec_()
        # view.resize(500, 300)
        # view.show()

        # msg = self.tr(u'Collection:')
        # msg += self.tr(u'\n- Id: {}'.format(collection_id))
        # for metadata in collection_metadata:
        #     msg += self.tr(u'\n- {}: {}'.format(metadata, collection_metadata[metadata]))
        # self.display_msg_error(msg)

        return

    def update_gui(self):
        if not self.logged:
            self.collectionComboBox.clear()
            self.loginPushButton.setEnabled(True)
            self.logoutPushButton.setEnabled(False)
            self.collectionComboBox.setEnabled(False)
            self.collectionMetadataPushButton.setEnabled(False)
            self.collectionInfoPushButton.setEnabled(False)
            self.bandsLineEdit.clear()
            self.bandsPushButton.setEnabled(False)
            self.indexComboBox.clear()
            self.indexComboBox.setEnabled(False)
            self.roiMapCanvasRadioButton.setEnabled(False)
            self.roiSelectedFeaturesRadioButton.setEnabled(False)
            self.outputPathPushButton.setEnabled(False)
            self.initialDateEdit.setEnabled(False)
            self.finalDateEdit.setEnabled(False)
            self.processPushButton.setEnabled(False)
            self.loadResultsPushButton.setEnabled(False)
            return
        # provider condition to do, at this moment is one valid
        self.loginPushButton.setEnabled(False)
        self.logoutPushButton.setEnabled(True)
        self.collectionComboBox.setEnabled(True)
        collection = self.collectionComboBox.currentText()
        if collection == definitions.CONST_NO_COMBO_SELECT:
            self.collectionMetadataPushButton.setEnabled(False)
            self.collectionInfoPushButton.setEnabled(False)
            self.bandsLineEdit.clear()
            self.bandsPushButton.setEnabled(False)
            self.indexComboBox.clear()
            self.indexComboBox.setEnabled(False)
            self.roiMapCanvasRadioButton.setEnabled(False)
            self.roiSelectedFeaturesRadioButton.setEnabled(False)
            self.outputPathPushButton.setEnabled(False)
            self.initialDateEdit.setEnabled(False)
            self.finalDateEdit.setEnabled(False)
            self.processPushButton.setEnabled(False)
            self.loadResultsPushButton.setEnabled(False)
            return
        self.collectionMetadataPushButton.setEnabled(True)
        self.collectionInfoPushButton.setEnabled(True)
        self.bandsPushButton.setEnabled(True)
        current_bands = self.bandsLineEdit.text()
        current_index = ""
        if self.indexComboBox.count() == 0:
            self.indexComboBox.setEnabled(False)
        else:
            self.indexComboBox.setEnabled(True)
            current_index = self.indexComboBox.currentText()
        if not current_bands and ( not current_index or current_index == definitions.CONST_NO_COMBO_SELECT):
            self.roiMapCanvasRadioButton.setEnabled(False)
            self.roiSelectedFeaturesRadioButton.setEnabled(False)
            self.outputPathPushButton.setEnabled(False)
            self.initialDateEdit.setEnabled(False)
            self.finalDateEdit.setEnabled(False)
            self.processPushButton.setEnabled(False)
            self.loadResultsPushButton.setEnabled(False)
            return
        self.roiMapCanvasRadioButton.setEnabled(True)
        self.roiSelectedFeaturesRadioButton.setEnabled(True)
        self.outputPathPushButton.setEnabled(True)
        self.initialDateEdit.setEnabled(True)
        self.finalDateEdit.setEnabled(True)
        self.processPushButton.setEnabled(False)
        self.loadResultsPushButton.setEnabled(False)
        output_path = self.outputPathLineEdit.text()
        if output_path:
            self.processPushButton.setEnabled(True)
            self.loadResultsPushButton.setEnabled(True)
        return